{"version":3,"sources":["../promise.js"],"names":["setTimeout","console","log","promise","Promise","resolve","reject","Math","random","then","data","p1","p2","p3","all","values","p4","p5","p6","value","err","timerPromisefy","delay","startDate","Date","now"],"mappings":"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","file":"promise.js","sourcesContent":["// 异步任务会在当前脚本的所有同步任务执行完才会执行, 如果同步代码中含有死循环，那么这个异步任务就不会执行\n\n// 定时器是异步的\n\nsetTimeout(function () {\n    console.log('task A async !')\n});\n\nconsole.log('task B sync');\n\n// task B sync\n// task A async !\n\n// 加入死循环示例\n\nsetTimeout(function () {\n    console.log('task A async !')\n});\n\nconsole.log('task B sync');\n\n// while (true);\n\n// task B sync\n\n// 如果同步代码中含有死循环，那么这个异步任务就不会执行\n\n\n// 回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码\n// 回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。\n// 在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。\n\n\n// Promise对象代表一个未完成、但预计将来会完成的操作\n// pending：初始值，不是fulfilled，也不是rejected\n// fulfilled：代表操作成功\n// rejected：代表操作失败\n// Promise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。\n// 一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。\n// 注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一\n\nlet promise = new Promise(function (resolve, reject) {\n    if (Math.random() > 0.5) {\n        resolve('Ok')\n    } else {\n        reject('Fail');\n    }\n});\n\n// resolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n// reject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去\n\n// Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。\n\npromise.then(function (data) {\n    console.log(data); // OK\n}, function (data) {\n    console.log(data); // FAIL\n});\n\n// then方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都接受Promise对象传出的值作为参数。\n// 新建Promise中的'resolve('OK')'，则相当于执行resolveFun函数。\n// Promise新建后就会立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行\n\n\n// 基本API\n\n// .then()\n// 对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。\n\n\n// .catch()\n// 该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数\n\n// promise.then(function(data) {\n//     console.log('success');\n// }).catch(function(error) {\n//     console.log('error', error);\n// });\n//\n// /*******等同于*******/\n// promise.then(function(data) {\n//     console.log('success');\n// }).then(undefined, function(error) {\n//     console.log('error', error);\n// });\n\n\n// .all()\n// 该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\nlet p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 3000, 'First');\n});\n\nlet p2 = new Promise(function (resolve, reject) {\n    resolve('second');\n});\n\nlet p3 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 1000, 'third');\n});\n\nPromise.all([p1, p2, p3])\n    .then(function (values) {\n        console.log(values); // [ 'First', 'second', 'third' ]\n    });\n\n// 当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数\n// 当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数\n\nlet p4 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 3000, 'one');\n});\n\nlet p5 = new Promise(function (resolve, reject) {\n    setTimeout(reject, 2000, 'two');\n});\n\nlet p6 = new Promise(function (resolve, reject) {\n    reject('three')\n});\n\nPromise.all([p4, p5, p6])\n    .then(function (value) {\n        console.log('resolve', value);\n    }, function (err) {\n        console.log('reject', err); // reject three\n    });\n\n// 多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128\n\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay)\n    });\n}\n\nlet startDate = Date.now();\n\nPromise.all([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (value) {\n    console.log(Date.now() - startDate + 'ms'); //133ms\n    console.log(value); // [1,32,64,128]\n});"]}