{"version":3,"sources":["../rxjs01.js"],"names":["DataSource","i","_id","setInterval","emit","n","limit","ondata","oncomplete","destory","clearInterval","myObservable","observer","datasource","e","next","onerror","err","error","complete","unsub","x","console","log","setTimeout","Rx","require","observable1","Observable","create","subscribe","value"],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;IACMA,U;AACF,0BAAc;AAAA;;AAAA;;AACV,YAAIC,IAAI,CAAR;AACA,aAAKC,GAAL,GAAWC,YAAY;AAAA,mBAAM,MAAKC,IAAL,CAAUH,GAAV,CAAN;AAAA,SAAZ,EAAkC,GAAlC,CAAX;AACH;;;;6BAEII,C,EAAG;AACJ,gBAAMC,QAAQ,EAAd;AACA,gBAAI,KAAKC,MAAT,EAAiB;AACb,qBAAKA,MAAL,CAAYF,CAAZ;AACH;AACD,gBAAIA,MAAMC,KAAV,EAAiB;AACb,oBAAI,KAAKE,UAAT,EAAqB;AACjB,yBAAKA,UAAL;AACH;AACD,qBAAKC,OAAL;AACH;AACJ;;;kCAES;AACNC,0BAAc,KAAKR,GAAnB;AACH;;;;;;AAGL;;;AACA,SAASS,YAAT,CAAsBC,QAAtB,EAAgC;AAC5B,QAAIC,aAAa,IAAIb,UAAJ,EAAjB;AACAa,eAAWN,MAAX,GAAoB,UAACO,CAAD;AAAA,eAAOF,SAASG,IAAT,CAAcD,CAAd,CAAP;AAAA,KAApB;AACAD,eAAWG,OAAX,GAAqB,UAACC,GAAD;AAAA,eAASL,SAASM,KAAT,CAAeD,GAAf,CAAT;AAAA,KAArB;AACAJ,eAAWL,UAAX,GAAwB;AAAA,eAAMI,SAASO,QAAT,EAAN;AAAA,KAAxB;AACA,WAAO,YAAM;AACTN,mBAAWJ,OAAX;AACH,KAFD;AAGH;;AAED,IAAMW,QAAQT,aAAa;AACvBI,UAAM,cAACM,CAAD;AAAA,eAAOC,QAAQC,GAAR,CAAYF,CAAZ,CAAP;AAAA,KADiB;AAEvBH,WAAO,eAACD,GAAD;AAAA,eAASK,QAAQJ,KAAR,CAAcD,GAAd,CAAT;AAAA,KAFgB;AAGvBE,cAAU;AAAA,eAAMG,QAAQC,GAAR,CAAY,SAAZ,CAAN;AAAA;AAHa,CAAb,CAAd;;AAMAC,WAAWJ,KAAX,EAAkB,IAAlB;;AAEA;;;AAGA;;AAEA,IAAMK,KAAKC,QAAQ,MAAR,CAAX;;AAEA,IAAIC,cAAcF,GAAGG,UAAH,CACbC,MADa,CACN,UAACjB,QAAD,EAAc;AAClBA,aAASG,IAAT,CAAc,SAAd;AACAH,aAASG,IAAT,CAAc,IAAd;AACH,CAJa,CAAlB;AAKA;AACAY,YACKG,SADL,CACe;AAAA,WAASR,QAAQC,GAAR,CAAYQ,KAAZ,CAAT;AAAA,CADf;AAEA;AACA","file":"rxjs01.js","sourcesContent":["// RxJS 是基于观察者模式和迭代器模式以函数式编程思维来实现的。RxJS 中含有两个基本概念：Observables 与 Observer。\n// Observables 作为被观察者，是一个值或事件的流集合；而 Observer 则作为观察者，根据 Observables 进行处理\n\n// Observables 与 Observer 之间的订阅发布关系(观察者模式) 如下：\n//\n// 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。\n// 发布：Observable 通过回调 next 方法向 Observer 发布事件。\n\n// Observable（被观察者）\n// 是一个函数，它接受一个 Observer 作为参数然后返回另一个函数。\n// 接受一个 Observer 对象 (包含 next、error、complete 方法的对象) 作为参数\n// 返回一个 unsubscribe 函数，用于取消订阅;\n// 作为生产者与观察者之间的桥梁，并返回一种方法来解除生产者与观察者之间的联系，其中观察者用于处理时间序列上数据流。接下来我们来看一下 Observable 的基础实现\n\n// 基础实现\n\n// 数据源：\nclass DataSource {\n    constructor() {\n        let i = 0;\n        this._id = setInterval(() => this.emit(i++), 200)\n    }\n\n    emit(n) {\n        const limit = 10;\n        if (this.ondata) {\n            this.ondata(n)\n        }\n        if (n === limit) {\n            if (this.oncomplete) {\n                this.oncomplete()\n            }\n            this.destory();\n        }\n    }\n\n    destory() {\n        clearInterval(this._id)\n    }\n}\n\n// 被观察者：\nfunction myObservable(observer) {\n    let datasource = new DataSource();\n    datasource.ondata = (e) => observer.next(e);\n    datasource.onerror = (err) => observer.error(err);\n    datasource.oncomplete = () => observer.complete();\n    return () => {\n        datasource.destory();\n    }\n}\n\nconst unsub = myObservable({\n    next: (x) => console.log(x),\n    error: (err) => console.error(err),\n    complete: () => console.log('Success')\n});\n\nsetTimeout(unsub, 1200);\n\n//结果，打印0-4\n\n\n//  Rx.Observable.create\n\nconst Rx = require('rxjs');\n\nlet observable1 = Rx.Observable\n    .create((observer) => {\n        observer.next('Lurance');\n        observer.next('He');\n    });\n// 订阅这个 Observable\nobservable1\n    .subscribe(value => console.log(value));\n// Lurance\n// He\n\n\n\n"]}