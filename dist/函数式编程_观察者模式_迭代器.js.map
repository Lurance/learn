{"version":3,"sources":["../函数式编程_观察者模式_迭代器.js"],"names":["a","b","c","add","mul","sub","a1","add5","console","log","Subject","observerCollection","observer","push","index","indexOf","splice","forEach","notify","Observer","name","subject","observer1","observer2","registerObserver","notifyObservers","unregisterObserver","makeIterator","array","nextIndex","next","length","value","done","it","arr","iter","Symbol","iterator"],"mappings":"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","file":"函数式编程_观察者模式_迭代器.js","sourcesContent":["// 函数式编程是一种编程范式\n\n// 它属于 \"结构化编程\" 的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用\n\n// 传统的过程式编程如下：\n\nlet a = 5 + 6;\nlet b = 1 * 3;\nlet c = a - b;\n\n// 函数式编程如下：\n\nconst add = (a, b) => a + b;\nconst mul = (a, b) => a * b;\nconst sub = (a,b) => a - b;\nsub(add(5,6), mul(1,3));\n\n\n// 函数式编程基础条件：函数为一等公民 (First Class)\n// 所谓 \"一等公民\"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为其它函数的返回值。\n\n// 例如作为返回值：\n\nconst a1 = (a) => (b) => a+ b;\n\nconst add5 = a1(5);\n\nconsole.log(add5(10)); // 15\n\n\n// Pure Function (纯函数) 的特点：\n// 给定相同的输入参数，总是返回相同的结果\n// 没有产生任何副作用\n// 没有依赖外部变量的值\n// 所谓 \"副作用\")（side effect），是指函数内做了与本身运算无关的事，比如修改某个全局变量的值，或发送 HTTP 请求，甚至函数体内执行 console.log 都算是副作用。\n// 函数式编程强调函数不能有副作用，也就是函数要保持纯粹，只执行相关运算并返回值，没有其他额外的行为\n// 前端中常见的产生副作用的场景：\n// 发送 HTTP 请求\n// 函数内调用 logger 函数，如 console.log、console.dir 等\n// 修改外部变量的值\n// 函数内执行 DOM 操作\n\n// 观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。\n//\n// 我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念。期刊订阅包含两个主要的角色：期刊出版方和订阅者，他们之间的关系如下：\n//\n// 期刊出版方 - 负责期刊的出版和发行工作\n// 订阅者 - 只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知\n// 在观察者模式中也有两个主要角色：Subject (主题) 和 Observer (观察者) 。它们分别对应例子中的期刊出版方和订阅者。接下来我们来看张图，从而加深对上面概念的理解。\n\n\n// 简易的Subject（主题与Observer（观察者）：\n\nclass Subject {\n\n    constructor() {\n        this.observerCollection = [];\n    }\n\n    registerObserver(observer) {\n        this.observerCollection.push(observer)\n    }\n\n    unregisterObserver(observer) {\n        let index = this.observerCollection.indexOf(observer);\n        if (index >= 0 ){\n            this.observerCollection.splice(index, 1)\n        }\n    }\n\n    notifyObservers() {\n        this.observerCollection.forEach(observer => observer.notify())\n    }\n}\n\nclass Observer {\n\n    constructor(name) {\n        this.name = name\n    }\n\n    notify() {\n        console.log(`${this.name} has been notified`)\n    }\n}\n\n// 使用示例：\n\nlet subject = new Subject();\n\nlet observer1 = new Observer('aaaa');\nlet observer2 = new Observer('bbbb');\n\nsubject.registerObserver(observer1);\nsubject.registerObserver(observer2);\n\nsubject.notifyObservers();\n// aaaa has been notified\n// bbbb has been notified\n\nsubject.unregisterObserver(observer1);\nsubject.notifyObservers();\n// bbbb has been notified\n\n\n\n// ECMAScript 迭代器\n\n// 一个迭代器对象 ，知道如何每次访问集合中的一项， 并记录它的当前在序列中所在的位置。\n// 在 JavaScript 中迭代器是一个对象，它提供了一个 next() 方法，返回序列中的下一项。这个方法返回包含 done 和 value 两个属性的对象。\n// 对象的取值如下：\n//\n// 在最后一个元素前：{ done: false, value: elementValue }\n// 在最后一个元素后：{ done: true, value: undefined }\n\n// ES5 迭代器示例：\n\nfunction makeIterator(array) {\n    var nextIndex = 0\n\n    return {\n        next: function () {\n            return nextIndex < array.length ? {value: array[nextIndex++], done: false} : {done: true}\n        }\n    }\n}\n\n// 一旦初始化, next() 方法可以用来依次访问可迭代对象中的元素：\n\nvar it = makeIterator(['aa', 'bb', 'cc', 'dd']);\nconsole.log(it.next().value); // aa\nconsole.log(it.next().value); // bb\nconsole.log(it.next().value); // cc\n\n\n// 在 ES 6 中我们可以通过 Symbol.iterator 来创建可迭代对象的内部迭代器，具体示例如下：\n\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\n\n// ES 6 中可迭代的对象：\n//\n// Arrays\n// Strings\n// Maps\n// Sets\n// DOM data structures (work in progress)"]}