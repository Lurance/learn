{"version":3,"sources":["../promise_async_await.js"],"names":["getData1","Promise","resolve","reject","setTimeout","console","log","getData2","params","asyncDemo2","arr","textPromises","map","doc","textPromise"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAT,GAAoB;AAChB,WAAO,IAAIC,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACrCC,mBAAW,YAAM;AACbC,oBAAQC,GAAR,CAAY,MAAZ;AACAJ,oBAAQ,aAAR;AACH,SAHD,EAGG,IAHH;AAIH,KALM,CAAP;AAMH;;AAED,SAASK,QAAT,CAAkBC,MAAlB,EAA0B;AACtB,WAAO,IAAIP,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACrCC,mBAAW,YAAM;AACbC,oBAAQC,GAAR,CAAY,MAAZ;AACAJ,oBAAQ,gBAAgBM,MAAxB;AACH,SAHD,EAGG,IAHH;AAIH,KALM,CAAP;AAMH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,eAAeC,UAAf,GAA6B;AACzB,QAAMC,MAAM,CAACV,QAAD,EAAWO,QAAX,CAAZ;AACA,QAAMI,eAAeD,IAAIE,GAAJ,CAAQ,gBAAOC,GAAP;AAAA,eAAe,MAAMA,KAArB;AAAA,KAAR,CAArB;AACAR,YAAQC,GAAR,CAAYK,YAAZ;AAHyB;AAAA;AAAA;;AAAA;AAIzB,6BAA0BA,YAA1B,8HAAwC;AAAA,gBAA7BG,WAA6B;;AACpCT,oBAAQC,GAAR,EAAY,MAAMQ,WAAlB;AACH;AANwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAO5B;;AAEDL;;AAEA","file":"promise_async_await.js","sourcesContent":["// // 回调是异步编程最基本的方法。\n//\n// // 假定有两个函数f1和f2，后者等待前者的执行结果。如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数\n//\n// // function f1(callback) {\n// //     setTimeout(function () {\n// //         callback();\n// //     }, 1000)\n// // }\n// //\n// // f1(f2);\n//\n// // 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。\n// // 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。\n//\n// // Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。\n// // 简单说，它的思想是， 每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n// // Promises的出现大大改善了异步编程的困境，避免出现回调地狱，嵌套层级得到改善\n//\n//\n// // 以下是两个基本的异步请求\n//\nfunction getData1() {\n    return new Promise(((resolve, reject) => {\n        setTimeout(() => {\n            console.log('1执行了');\n            resolve('请求到模拟数据1111')\n        }, 2000)\n    }));\n}\n\nfunction getData2(params) {\n    return new Promise(((resolve, reject) => {\n        setTimeout(() => {\n            console.log('2执行了');\n            resolve('请求到模拟数据2222' + params)\n        }, 2000)\n    }));\n}\n//\n// // promise 实现异步回调 异步列队\n// // 1请求完成后，把1的响应参数传入2，在发2请求\n//\n// getData1()\n//     .then(res => {\n//         return getData2(res);\n//     })\n//     .then(res => console.log(res));\n//\n// // 1执行了\n// // 2执行了\n// // 请求到模拟数据22222拉！params：请求到模拟数据1111拉   用时 3500 ms\n//\n//\n// // promise.all() 实现异步回调 并发 所有的完成\n// // 1请求、2请求同时发,两条响应都收到后在执行\n// Promise.all([getData1(), getData2()])\n//     .then(res => console.log(res));\n//\n// // 2执行了\n// // 1执行了\n// // [\"请求到模拟数据1111拉\", \"请求到模拟数据22222拉！params：undefined\"]   用时 2000 ms\n//\n//\n// // promise.race() 实现异步回调 并发 竞速\n// // 1请求、2请求同时发，其中一条收到请求就执行\n// Promise.race([getData1(), getData2()])\n//     .then(res => console.log(res));\n//\n// // 2执行了\n// // 请求到模拟数据22222拉！params：undefined    用时 1500 ms\n// // 1执行了\n//\n//\n//\n//\n// // Async/await 是Javascript编写异步程序的新方法。以往的异步方法无外乎回调函数和Promise。但是Async/await建立于Promise之上。\n//\n// async function timeout(ms) {\n//     await new Promise(resolve => setTimeout(resolve, ms))\n// }\n//\n// async function asyncPrint(value, ms) {\n//     await timeout(ms);\n//     console.log(value);\n// }\n//\n// asyncPrint('hello world', 3000);\n//\n// // 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖\n//\n// // 改写\n// // getData1()\n// //     .then(res => {\n// //         return getData2(res);\n// //     })\n// //     .then(res => console.log(res));\n//\n//\n// async function asyncDemo() {\n//     const r1 = await getData1();\n//     const r2 = await getData2(r1);\n//     console.log(r2);\n// }\n\n// 1执行了\n// 2执行了\n// 请求到模拟数据22222拉！params：请求到模拟数据1111拉   用时 3500 ms\n\n\n//假如我们有一种这样的业务需求，并发两个请求，但是要规定收到请求的顺序应该怎么做的？\n\nasync function asyncDemo2 () {\n    const arr = [getData1, getData2];\n    const textPromises = arr.map(async (doc) => await doc());\n    console.log(textPromises);\n    for (const textPromise of textPromises) {\n        console.log(await textPromise);\n    }\n}\n\nasyncDemo2();\n\n// 代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响\n\n"]}